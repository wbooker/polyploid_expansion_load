initialize()
{
	//set as nonWF model
	initializeSLiMModelType("nonWF");
	
	//set mutation rate
	initializeMutationRate(0.000000000025);
	
	// m1 mutation type: beneficial
	initializeMutationType("m1", 0.5, "f", 0.005);
	
	// m2 mutation type: deleterious
	initializeMutationType("m2", 0.5, "f", -0.005);
	
	// g1 genomic element type: 10% beneficial and 90% deleterious on all mutations
	initializeGenomicElementType("g1", c(m1, m2), c(0.1, 0.9));
	
	// uniform chromosome of length 10 kb with uniform recombination
	initializeGenomicElement(g1, 0, 999999999);
	initializeRecombinationRate(0.000000000025);
	
	//set global population parameters
	defineConstant("K", 75); // carrying-capacity density
	//defineConstant("n_demes", 1000); //number of demes
	defineConstant("mig_rate", 0.05); //mig rate
	defineConstant("r", log(2)); //growth rate
	defineGlobal("inheritance", "allo");

	defineGlobal("previous_deme", 0);

}

1 early()
{
	print(inheritance);
	print("k: " + K +  " r: " + r + " m: " + mig_rate);
	//first deme holds extra chromosomes of every individual. individuals don't migrate from or into here
	sim.addSubpop(1, K*5);

	//initialize next 5 demes at carrying_capacity
	for (i in 2:6){
		sim.addSubpop(i, K);

		//create individual tags to keep track of chromosomes
		for(j in seqLen(sim.subpopulations[i - 1].individualCount)){
			//defineGlobal("c_tag", (c_tag+1));
			c_tag = runif(1);
			sim.subpopulations[i - 1].individuals[j].tagF = c_tag;
			sim.subpopulations[0].individuals[j+((i-2)*K)].tagF = c_tag;
			//sim.subpopulations[i - 1].individuals[j].tag = c_tag;
		}
	}
	
}

survival(p1) {
// move dying males into cold storage in case they have mated

 if (individual.age == 0)
 	return T;
 return NULL;
}



//open up other populations after 10k generations
1001 first()
{
	//initialize rest of demes at 0
		sim.addSubpop(7, 0);
		//sim.chromosome.setMutationRate(0.000000000025);
}

early()
{
	// parents die; offspring survive proportional to fitness (Generations discrete and non-overlapping)
	for (i in 1:size(sim.subpopulations))
	{
		inds = sim.subpopulations[i - 1].individuals;
		inds[inds.age > 0].fitnessScaling = 0.0;
	}
	
	//forward mig
	for (i in 2:(size(sim.subpopulations) - 1))
	{
		nIndividuals = sim.subpopulations[i - 1].individualCount;
		if (nIndividuals > 0){		
			nMigrants = rpois(1, nIndividuals * mig_rate);
			if (nMigrants >= 1){
				mig_inds = sim.subpopulations[i - 1].individuals;
				if (size(mig_inds) >= 1){
					if(nMigrants > size(mig_inds))
						nMigrants = size(mig_inds);
					migrants = sample(mig_inds, nMigrants);
					for (migrant in migrants)
					{
						dest = i;
						sim.subpopulations[dest].takeMigrants(migrant);
					}
				}
			}
		}
	}
	
	//reverse mig
	for (i in 3:size(sim.subpopulations))
	{
		nIndividuals = sim.subpopulations[i - 1].individualCount;
		if (nIndividuals > 0){
			nMigrants = rpois(1, nIndividuals * mig_rate);
			if (nMigrants >= 1){
				mig_inds = sim.subpopulations[i - 1].individuals;
				if (size(mig_inds) >= 1){
					if(nMigrants > size(mig_inds))
						nMigrants = size(mig_inds);
					migrants = sample(mig_inds, nMigrants);
					for (migrant in migrants)
					{
						dest = i - 2;
						sim.subpopulations[dest].takeMigrants(migrant);
					}
				}
			}
		}	
	}
}

//set reproduction
reproduction()
{


	//logistic growth
	for (i in 2:size(sim.subpopulations))
	{
		N_star = (exp(r) * sim.subpopulations[i - 1].individualCount) / (1 + ((exp(r) - 1) * sim.subpopulations[i - 1].individualCount / K));
		if (N_star > 0)
		{
			N_prime = rpois(1, N_star);
			inds = sim.subpopulations[i - 1].individuals;
			fitness = sim.subpopulations[i - 1].cachedFitness(NULL);
			parents1 = sample(inds, N_prime, replace=T);
			parents2 = sample(inds, N_prime, replace=T);
			for (j in seqLen(N_prime))
			{
				p1_chroms = c(parents1[j].genomes, sim.subpopulations[0].individuals[parents1[j].tag].genomes);
				p2_chroms = c(parents2[j].genomes, sim.subpopulations[0].individuals[parents2[j].tag].genomes);
				p1_order = seq(from = 0, to = 3, by = 1);
				p2_order = seq(from = 0, to = 3, by = 1);
				if(inheritance == "auto"){
					p1_order = sample(seqLen(4), 4);
					p2_order = sample(seqLen(4), 4);
				}
				breakpoints1 = sim.chromosome.drawBreakpoints();
				breakpoints2 = sim.chromosome.drawBreakpoints();
				offspring = sim.subpopulations[i - 1].addRecombinant(p1_chroms[p1_order[0]], p1_chroms[p1_order[1]], breakpoints1, p2_chroms[p2_order[0]], p2_chroms[p2_order[1]], breakpoints2);
				breakpoints1 = sim.chromosome.drawBreakpoints();
				breakpoints2 = sim.chromosome.drawBreakpoints();
				other = sim.subpopulations[0].addRecombinant(p1_chroms[p1_order[2]], p1_chroms[p1_order[3]], breakpoints1, p2_chroms[p2_order[2]], p2_chroms[p2_order[3]], breakpoints2);
				//defineGlobal("c_tag", (c_tag+1));
				c_tag = runif(1);
				offspring.tagF = c_tag; //these aren't getting set for some reason
				other.tagF = c_tag;
			}
		}
	}
	self.active = 0;
}


1002:200000 late()
{
	if (sim.subpopulations[size(sim.subpopulations)-1].individualCount > 0){
		sim.addSubpop(size(sim.subpopulations)+1, 0);
	}
}

// need to set tags for new individuals after selection induced mortality
early(){

	inds = sim.subpopulations[seq(from = 1, to = (size(sim.subpopulations)-1), by = 1)].individuals;
	tag = match(inds.tagF, sim.subpopulations[0].individuals.tagF);
	inds.tag = tag;
}

2: late() {

	inds = sim.subpopulations[seq(from = 1, to = (size(sim.subpopulations)-1), by = 1)].individuals;
	tag = match(inds.tagF, sim.subpopulations[0].individuals.tagF);
	inds.tag = tag;
}

mutationEffect(m1){
	if(individual.subpopulation == p1){
		return 1.0;
	}
	h = c(0.0, 0.25, 0.5, 0.75, 1.0);
	other = sim.subpopulations[0].individuals[individual.tag];
	n = sum(individual.genomes.containsMutations(mut)) + sum(other.genomes.containsMutations(mut));
	return 1 + h[n] * mut.selectionCoeff;
}

mutationEffect(m2){
	if(individual.subpopulation == p1){
		return 1.0;
	}
	h = c(0.0, 0.25, 0.5, 0.75, 1.0);
	other = sim.subpopulations[0].individuals[individual.tag];
	//print(individual.tagF);
	//print(other.tagF);
	n = sum(individual.genomes.containsMutations(mut)) + sum(other.genomes.containsMutations(mut));
	return 1 + h[n] * mut.selectionCoeff;
}

//do a quick check to make sure tags are right every 100 gens
101: first (){
	check_ticks = seq(from=101,to=200001,by=100);
	if(match(community.tick, check_ticks) >= 0){
		for (ind in sim.subpopulations[seq(from = 1, to = (size(sim.subpopulations)-1), by = 1)].individuals)
			if (ind.tagF != sim.subpopulations[0].individuals[ind.tag].tagF)
				stop("late(): error for individual " + ind.index);
	}
}

//do a quick check to make sure tags are right every 100 gens
101: early (){
	check_ticks = seq(from=101,to=200001,by=100);
	if(match(community.tick, check_ticks) >= 0){
		for (ind in sim.subpopulations[seq(from = 1, to = (size(sim.subpopulations)-1), by = 1)].individuals)
			if (ind.tagF != sim.subpopulations[0].individuals[ind.tag].tagF)
				stop("late(): error for individual " + ind.index);
	}
}

//do a quick check to make sure tags are right every 100 gens
101: late (){
	check_ticks = seq(from=101,to=200001,by=100);
	if(match(community.tick, check_ticks) >= 0){
		for (ind in sim.subpopulations[seq(from = 1, to = (size(sim.subpopulations)-1), by = 1)].individuals)
			if (ind.tagF != sim.subpopulations[0].individuals[ind.tag].tagF)
				stop("late(): error for individual " + ind.index);
	}
}

1001:200001 late()
{
	output_ticks = seq(from=1001,to=200001,by=50);
	if(match(community.tick, output_ticks) >= 0){
		defineGlobal("current_deme", (size(sim.subpopulations)-1));
		while(isNULL(mean(sim.subpopulations[current_deme].cachedFitness(NULL)))){
			defineGlobal("current_deme", (current_deme-1));
		}
		speed = (current_deme - previous_deme) / 50;
		defineGlobal("previous_deme", current_deme);
		fitness_start = mean(sim.subpopulations[1].cachedFitness(NULL));
		fitness_mid = mean(sim.subpopulations[round((current_deme-1)/2)].cachedFitness(NULL));
		fitness_edge = mean(sim.subpopulations[current_deme].cachedFitness(NULL));

		//log output
		if(community.tick == 1001){
			outDir = paste0(c("output/",inheritance,"_",K,"_",mig_rate,"_",r,"/"));
			createDirectory(outDir);
			if(isNULL(readFile(paste0(outDir,"trackFile.txt")))){
				writeFile(paste0(outDir,"trackFile.txt"), "0", append = F);
				curr_rep = 0;
			}
			if(!isNULL(readFile(paste0(outDir,"trackFile.txt")))){
				trackFile = readFile(paste0(outDir,"trackFile.txt"));
				curr_rep = asInteger(trackFile[0])+1;
				writeFile(paste0(outDir,"trackFile.txt"), asString(curr_rep), append = F);
			}
			outfile = paste0(c(outDir,curr_rep,"_log.csv"));			
			log = community.createLogFile(outfile, logInterval=50);
 			log.addCycle(); 
			log.addCustomColumn("Generation", "community.tick;"); 
			log.addCustomColumn("start_fitness", "mean(sim.subpopulations[1].cachedFitness(NULL));");
			log.addCustomColumn("mid_fitness", "mean(sim.subpopulations[round((current_deme-1)/2)].cachedFitness(NULL));");
			log.addCustomColumn("edge_fitness", "mean(sim.subpopulations[current_deme].cachedFitness(NULL));");
			log.addCustomColumn("current_deme", "current_deme;");
			
			// intitialize log  for fitnesses of each subpop
			defineGlobal("fitness_file", paste0(c(outDir,curr_rep,"_fitnesses.csv")));
			writeFile(fitness_file, paste(seq(from = 0, to = 5000, by = 1), sep=","), append = F);
			
		}
		//update fitness file
		sub_fitnesses = NULL;
		for (i in 2:size(sim.subpopulations)){
			sub_fitnesses = c(sub_fitnesses, mean(sim.subpopulations[i-1].cachedFitness(NULL)));
		}
		extra_pops = rep(0, (5000-current_deme+1));
		fitness_line = c(sub_fitnesses, extra_pops);
		writeFile(fitness_file, paste(fitness_line, sep=","), append = T);
		
		//print to std out
		print("tick: " + community.tick + " time: " + time() + " start: " + fitness_start + " mid: " + fitness_mid + " edge: " + fitness_edge + " demes: " + current_deme + " speed: " + speed);
		}
}