initialize()
{
	//set as nonWF model
	initializeSLiMModelType("nonWF");
	
	//set mutation rate
	initializeMutationRate(0.000005);
	
	// m1 mutation type: beneficial
	initializeMutationType("m1", 0.5, "f", 0.005);
	
	// m2 mutation type: deleterious
	initializeMutationType("m2", 0.5, "f", -0.005);
	
	// g1 genomic element type: 10% beneficial and 90% deleterious on all mutations
	initializeGenomicElementType("g1", c(m1, m2), c(0.1, 0.9));
	
	// uniform chromosome of length 10 kb with uniform recombination
	initializeGenomicElement(g1, 0, 999);
	initializeRecombinationRate(0.000005);
	
	//set global population parameters
	defineConstant("K", 100); // carrying-capacity density
	//defineConstant("n_demes", 1000); //number of demes
	defineConstant("mig_rate", 0.05); //mig rate
	defineConstant("r", log(2)); //growth rate
}

1 first()
{
	//initialize first 5 demes at carrying_capacity
	for (i in 1:5)
		sim.addSubpop(i, K);
}

1:10000 early()
{
	// parents die; offspring survive proportional to fitness (Generations discrete and non-overlapping)
	for (i in 1:5)
	{
		inds = sim.subpopulations[i - 1].individuals;
		inds[inds.age > 0].fitnessScaling = 0.0;
	}
	
	//forward mig
	for (i in 1:4)
	{
		nIndividuals = sim.subpopulations[i - 1].individualCount;
		if (nIndividuals > 0){		
			nMigrants = rpois(1, nIndividuals * mig_rate);
			if (nMigrants >= 1){
				mig_inds = sim.subpopulations[i - 1].individuals;
				if (size(mig_inds) >= 1){
					if(nMigrants > size(mig_inds))
						nMigrants = size(mig_inds);
					migrants = sample(mig_inds, nMigrants);
					for (migrant in migrants)
					{
						dest = i;
						sim.subpopulations[dest].takeMigrants(migrant);
					}
				}
			}
		}
	}
	
	//reverse mig
	for (i in 2:5)
	{
		nIndividuals = sim.subpopulations[i - 1].individualCount;
		if (nIndividuals > 0){
			nMigrants = rpois(1, nIndividuals * mig_rate);
			if (nMigrants >= 1){
				mig_inds = sim.subpopulations[i - 1].individuals;
				if (size(mig_inds) >= 1){
					if(nMigrants > size(mig_inds))
						nMigrants = size(mig_inds);
					migrants = sample(mig_inds, nMigrants);
					for (migrant in migrants)
					{
						dest = i - 2;
						sim.subpopulations[dest].takeMigrants(migrant);
					}
				}
			}
		}	
	}
}

//open up other populations after 10k generations
10001 first()
{
	//rescale fitness to 1 (only at edge pop??)
	sim.subpopulations[1 - 1].fitnessScaling = 1 / mean(sim.subpopulations[1 - 1].cachedFitness(NULL));
	sim.subpopulations[2 - 1].fitnessScaling = 1 / mean(sim.subpopulations[2 - 1].cachedFitness(NULL));
	sim.subpopulations[3 - 1].fitnessScaling = 1 / mean(sim.subpopulations[3 - 1].cachedFitness(NULL));
	sim.subpopulations[4 - 1].fitnessScaling = 1 / mean(sim.subpopulations[4 - 1].cachedFitness(NULL));
	sim.subpopulations[5 - 1].fitnessScaling = 1 / mean(sim.subpopulations[5 - 1].cachedFitness(NULL));
	
	//initialize rest of demes at 0
	for (i in 6:20)
		sim.addSubpop(i, 0);
}

10001:20000 early()
{
	// parents die; offspring survive proportional to fitness (Generations discrete and non-overlapping)
	for (i in 1:size(sim.subpopulations))
	{
		inds = sim.subpopulations[i - 1].individuals;
		inds[inds.age > 0].fitnessScaling = 0.0;
	}
	
	//forward mig
	for (i in 1:(size(sim.subpopulations) - 1))
	{
		nIndividuals = sim.subpopulations[i - 1].individualCount;
		if (nIndividuals > 0){		
			nMigrants = rpois(1, nIndividuals * mig_rate);
			if (nMigrants >= 1){
				mig_inds = sim.subpopulations[i - 1].individuals;
				if (size(mig_inds) >= 1){
					if(nMigrants > size(mig_inds))
						nMigrants = size(mig_inds);
					migrants = sample(mig_inds, nMigrants);
					for (migrant in migrants)
					{
						dest = i;
						sim.subpopulations[dest].takeMigrants(migrant);
					}
				}
			}
		}
	}
	
	//reverse mig
	for (i in 2:size(sim.subpopulations))
	{
		nIndividuals = sim.subpopulations[i - 1].individualCount;
		if (nIndividuals > 0){
			nMigrants = rpois(1, nIndividuals * mig_rate);
			if (nMigrants >= 1){
				mig_inds = sim.subpopulations[i - 1].individuals;
				if (size(mig_inds) >= 1){
					if(nMigrants > size(mig_inds))
						nMigrants = size(mig_inds);
					migrants = sample(mig_inds, nMigrants);
					for (migrant in migrants)
					{
						dest = i - 2;
						sim.subpopulations[dest].takeMigrants(migrant);
					}
				}
			}
		}	
	}
}

//set reproduction
2:10000 reproduction()
{
	//logistic growth
	for (i in 1:5)
	{
		N_star = (exp(r) * sim.subpopulations[i - 1].individualCount) / (1 + ((exp(r) - 1) * sim.subpopulations[i - 1].individualCount / K));
		if (N_star > 0){
			N_prime = rpois(1, N_star);
			inds = sim.subpopulations[i - 1].individuals;
			fitness = sim.subpopulations[i - 1].cachedFitness(NULL);
			parents1 = sample(inds, N_prime, replace=T, weights=fitness);
			parents2 = sample(inds, N_prime, replace=T, weights=fitness);
			for (j in seqLen(N_prime))
				sim.subpopulations[i - 1].addCrossed(parents1[j], parents2[j]);
			}
		}
	self.active = 0;
}

10001:20000 reproduction()
{
	//logistic growth
	for (i in 1:size(sim.subpopulations))
	{
		N_star = (exp(r) * sim.subpopulations[i - 1].individualCount) / (1 + ((exp(r) - 1) * sim.subpopulations[i - 1].individualCount / K));
		if (N_star > 0){
			N_prime = rpois(1, N_star);
			inds = sim.subpopulations[i - 1].individuals;
			fitness = sim.subpopulations[i - 1].cachedFitness(NULL);
			parents1 = sample(inds, N_prime, replace=T, weights=fitness);
			parents2 = sample(inds, N_prime, replace=T, weights=fitness);
			for (j in seqLen(N_prime))
				sim.subpopulations[i - 1].addCrossed(parents1[j], parents2[j]);
		}
	}
	self.active = 0;
}

10002:20000 late()
{
	if (sim.subpopulations[size(sim.subpopulations)-6].individualCount > 0){
		for (i in (size(sim.subpopulations)+1):(size(sim.subpopulations)+10))
			sim.addSubpop(i, 0);
	}
}

// output some metrics after 10k generations
20000 late()
{
	i = 100;
	fitness = sim.subpopulations[i - 1].cachedFitness(NULL);
	print(fitness);
}